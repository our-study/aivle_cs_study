# Untitled

# 3. 명령어

## 1. 소스 코드와 명령어

### 고급 언어와 저급 언어

- 고급 언어: 사람을 위한 언어(C, C++, Java, Python)
- 저급 언어: 컴퓨터가 직접 이해하고 실행할 수 있는 언어(명령어)

컴퓨터가 이해하고 실행할 수 있는 언어는 오직 저급 언어뿐이다. 그래서 고급 언어로 작성된  소스 코드가 실행되려면 반드시 저급 언어, 즉 명령어로 변환되어야 한다.

- 저급 언어의 종류
    1. 기계어: 0과 1의 명령어 비트로 이루어진 언어(이진수와 십육진수)
    2. 어셈블리어: 0과 1로 표현된 명령어를 읽기 편한 형태로 번역한 언어(특정 분야에서 관찰의 대상)

### 컴파일 언어와 인터프리터 언어

- 고급 언어가 저급 언어로 변환하는 과정
    1. 컴파일 언어: 컴파일 방식으로 작동하는 프로그래밍 언어
        1. 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환 되어 실행 되는 고급 언어(C 언어)
        2. 컴파일을 수행해 주는 도구를 컴파일러라고 한다.
        3. 컴파일러를 통해 저급 언어로 변환된 코드를 목적 코드라고 한다.
    2. 인터프리터 언어: 인터프리트 방식으로 작동하는 프로그래밍 언어
        1. 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어(Python)
        2. 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해 주는 도구를 인터프리터라고 한다.
        3. 소스 코드를 한 줄씩 실행하기 때문에 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없음
        4. 문법에 오류가 있더라도 오류가 있는 전 줄까지는 올바르게 수행
        5. 인터프리터가 컴파일 언어보다 느림

## 2. 명령어의 구조

### 연산 코드와 오퍼랜드

1. 연산 코드(연산자): 명령어가 수행할 연산
    1. 가장 기본적인 연산 코드 유형은 크게 네 가지로 나눌 수 있다.
        1. 데이터 전송
            1. MOVE: 데이터를 옮겨라
            2. STORE: 메모리에 저장하라
            3. LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라
            4. PUSH: 스택에 데이터를 저장하라
            5. POP: 스택의 최상단 데이터를 가져와라
        2. 산술/논리 연산
            1. ADD / SUBTRACT / MULTIPLY / DIVIDE: 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라
            2. INCREMENT / DECREMENT: 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
            3. AND / OR / NOT: AND / OR / NOT 연산을 수행하라
            4. COMPARE: 두 개의  숫자 또는 TRUE / FALSE 값을 비교하라
        3. 제어 흐름 변경
            1. JUMP: 특정 주소로 실행 순서를 옮겨라
            2. CONDITIONAL JUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
            3. HALT: 프로그램의 실행을 멈춰라
            4. CALL: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
            5. RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라
        4. 입출력 제어
            1. READ(INPUT): 특정 입출력 장치로부터 데이터를 읽어라
            2. WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라
            3. START IO: 입출력 장치를 시작하라
            4. TEST IO: 입출력 장치의 상태를 확인하라
    2. 명령어의 종류와 생김새는 CPU마다 다르다.
2. 오퍼랜드(피연산자): 연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치
    1. 오퍼랜드 필드에는 숫자나 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 온다.
    2. 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다.
    3. 그래서 오퍼랜드 필드를 주소 필드라고 부르기도 한다.
    4. 오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한 개, 두 개 또는 여러 개가 있을 수도 있다.
    5. 오퍼랜드가 하나도 없는 명령어를 0-주소 명령어라고 하고 하나인 명령어를 1-주소 명령어라고 한다.

### 주소 지정 방식

- 유효 주소: 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치
- 주소 지정 방식: 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법
    1. 즉시 주소 지정 방식
        1. 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
        2. 가장 간단한 형태의 주소 지정 방식
        3. 표현할 수 있는 데이터의 크기가 작아지는 단점이 있음
        4. 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없어 빠름
    2. 직접 주소 지정 방식
        1. 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
        2. 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수 만큼 줄어듦
        3. 유효 주소에 제한이 생길 수 있음
    3. 간접 주소 지정 방식
        1. 유효 주소의 주소를 오퍼랜드 필드에 명시
        2. 위의 방식들보다 일반적으로 느리다
    4. 레지스터 주소 지정 방식
        1. 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
        2. CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠름
        3. 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다
    5. 레지스터 간접 주소 지정 방식
        1. 연산에 사용할 데이터를 메모리에 저장하고, 저장한 레지스터를 오퍼랜드 필드에 명시
        2. 메모리에 접근하는 횟수가 한 번으로 줄어드는 장점을 가짐
        3. 

# 4. CPU의 작동 원리

## 1. ALU와 제어 장치

### ALU

- 계산하는 부품
- 받아들이는 정보
    1. 레지스터를 통해 피연산자를, 제어 장치로부터 제어 신호를 받아드림
    2. 레지스터와 제어 장치로부터 받아들인 피연산자와 제어 신호로 산술 연산, 논리 연산 등을 수행
- 내보내는 정보
    1. 연산을 수행한 결과(특정 숫자나 문자, 메모리 주소) - 일시적으로 레지스터에 저장
    2. 플래그(연산을 수행한 결과의 추가 정보)
- 플래그
    1. 연산 결과에 대한 추가적인 상태 정보
    2. 부호, 제로, 캐리, 오버플로우, 인터럽트, 슈퍼바이저
    3. 플래그들은 플래그 레지스터라는 레지스터에 저장

### 제어 장치

- 제어 신호를 내보내고, 명령어를 해석하는 부품
    - 제어 신호는 컴퓨터 부품을 관리하고 작동시키기 위한 일종의 전기 신호
- 제어 장치는 CPU의 구성 요소 중 가장 정교하게 설계된 부품
- CPU 제조사마다 조금씩 차이가 있음
- 받아들이는 정보
    1. 클럭(시간 단위) 신호
    2. 해석해야 할 명령어
    3. 플래그 레지스터 속 플래그 값
    4. 시스템 버스, 그중에서 제어 버스로 전달 된 제어 신호
- 내보내는 정보
    1. CPU 외부에 전달하는 제어 신호 → 제어 버스로 제어 신호를 내보낸다
    2. CPU 내부에 전달하는 제어 신호

### 레지스터

- 반드시 알아야 할 레지스터
1. 프로그램 카운터: 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소 저장
2. 명령어 레지스터: 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터
3. 메모리 주소 레지스터: 메모리의 주소를 저장하는 레지스터
4. 메모리 버퍼 레지스터: 메모리와 주고받을 값을 저장하는 레지스터
5. 플래그 레지스터: 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터
6. 범용 레지스터: 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
7. 스택 포인터: 스택의 꼭대기를 가리키는 레지스터(스택 주소 지정 방식 사용)
8. 베이스 레지스터

### 명령어 사이클

- 하나의 명령어를 처리하는 정형화된 흐름
- 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 명령어 사이클이라고 한다.
- 인출 사이클: 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- 실행 사이클: CPU로 가져온 명령어를 실행하는 단계
- 간접 사이클: 명령어를 실행하기 위해 메모리 접근을 하는 단계

### 인터럽트

- 정해진 흐름이 끊어지는 상황
- CPU가 수행 중인 작업을 방해하는 신호
- 동기 인터럽트: CPU에 의해 발생하는 인터럽트
- 비동기 인터럽트(하드웨어 인터럽트): 입출력 장치에 의해 발생하는 인터럽트

### 하드웨어 인터럽트

- 처리 순서
    1. 입출력장치는 CPU에 인터럽트 요청 신호를 보냄
    2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부 확인
    3. 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인
    4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
    5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행합니다.
    6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행
- 인터럽트 서비스 루틴: 인터럽트를 처리하기 위한 프로그램
- 인터럽트 벡터: 인터럽트 서비스 루틴을 식별하기 위한 정보
- 인터럽트 요청 신호: CPU의 작업을 방해하는 인터럽트에 대한 정보
- 인터럽트 플래그: 인터럽트 요정 신호를 받아들일지 무시할지 결정하는 비트

### 예외의 종류

1. 폴트: 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외
2. 트랩: 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
3. 중단: CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 오류
4. 소프트웨어 인터럽트: 시스템 호출이 발생했을 때 나타나는 오류