## CH3. 명령어

소스코드 → 명령어
고급 언어: 사람을 위한 언어
- 컴파일 언어: 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
- 인터프리터 언어: 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어
저급 언어: 컴퓨터가 직접 이해하고 실행할 수 있는 언어
- 기계어: 0과 1의 명령어 비트로 이루어진 언어
- 어셈블리어: 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어

목적 코드 + 링킹 → 실행 파일

명령어 = 연산 코드 + 오퍼랜드
1. 연산 코드(연산자): 명령어가 수행할 연산
- 데이터 전송: MOVE, STORE, LOAD, PUSH, POP
- 산술/논리 연산: ADD, SUBTRACT, MULTIPLY, DIVIDE, INCREMENT, DECREMENT, AND, OR, NOT, COMPARE
- 제어 흐름 변경: JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN
- 입출력 제어: READ, WRITE, START IO, TEST IO
2. 오퍼랜드(피연산자): 연산에 사용할 데이터 또는 그 데이터가 저장된 위치
- 0-주소 명령어: 오퍼랜드가 하나도 없는 명령어
- 1-주소 명령어: 오퍼랜드가 하나인 명령어
- 2-주소 명령어: 오퍼랜드가 두 개인 명령어
- 3-주소 명령어: 오퍼랜드가 세 개인 명령어

주소 지정 방식
- 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법
1. 즉시 주소 지정 방식: 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
2. 직접 주소 지정 방식: 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
3. 간접 주소 지정 방식: 유효 주소의 주소를 오퍼랜드 필드에 명시
4. 레지스터 주소 지정 방식: 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
5. 레지스터 간접 주소 지정 방식: 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법
6. 스택 주소 지정 방식: 스택과 스택 포인터를 이용한 주소 지정 방식
7. 변위 주소 지정 방식: 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
- 7.1. 상대 주소 지정 방식: 오퍼랜드와 프로그램 카운터(읽어 들일 명령어의 주소)의 값을 더하여 유효 주소를 얻는 방식
- 7.2. 베이스 레지스터 주소 지정 방식: 오퍼랜드(기준 주소로부터 떨어진 거리)와 베이스 레지스터(기준 주소)의 값을 더하여 유효 주소를 얻는 방식

스택
- 한쪽 끝이 막혀 있는 통과 같은 저장 공간
- LIFO(후입선출)
- PUSH, POP

큐
- 양쪽이 뚫려 있는 통과 같은 저장 공간
- FIFO(선입선출)


## CH4. CPU의 작동 원리

ALU
- 계산 담당
- INPUT: 피연산자(레지스터), 제어 신호(제어장치)
- OUTPUT: 연산한 결과값(레지스터), 플래그(플래그 레지스터)
- 플래그: 연산 결과에 대한 추가적인 상태 정보(부호, 제로, 캐리, 오버플로우 등)

제어장치
- 제어 신호를 내보내고 명령어를 읽고 해석
- INPUT: 모든 클럭 신호, 해석해야 할 명령어(명령어 레지스터), 플래그(플래그 레지스터), 제어 신호(시스템 버스)
- OUTPUT: CPU 외부 제어 신호, CPU 내부 제어 신호

레지스터
1. 프로그램 카운터: 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소 저장
2. 명령어 레지스터: 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장
3. 메모리 주소 레지스터: 메모리의 주소를 저장하는 레지스터
4. 메모리 버퍼 레지스터: 메모리와 주고 받을 값(데이터와 명령어)을 저장하는 레지스터
5. 플래그 레지스터: 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터
6. 범용 레지스터: 일반적인 상황에서 자유롭게 사용 가능한 레지스터
7. 스택 포인터 - 스택 주소 지정 방식, 스택의 꼭대기를 가리키는 레지스터
8. 베이스 레지스터 - 변위 주소 지정 방식

명령어 사이클
- 하나의 명령어를 처리하는 정형화된 흐름
- 인출 사이클: 메모리에 있는 명령어를 CPU로 가져오는 단계
- 실행 사이클: CPU로 가져온 명령어를 실행하는 단계
- 간접 사이클: 명령어를 실행하기 위해 한 번 더 메모리 접근을 하는 단계

인터럽트
- CPU의 작업을 방해하는 신호
- 동기 인터럽트: CPU에 의해 발생하는 인터럽트(예외)
- 비동기 인터럽트: 주로 입출력장치에 의해 발생하는 인터럽트(하드웨어 인터럽트)

하드웨어 인터럽트 처리 순서
1. 입출력장치는 CPU에 인터럽트 요청 신호 전송
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
- 인터럽트 벡터: 인터럽트 서비스 루틴을 식별하기 위한 정보
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행 재개

폴트: 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외
트랩: 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외

중단: CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
소프트웨어 인터럽트: 시스템 호출이 발생했을 때 나타나는 예외

